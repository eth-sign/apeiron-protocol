---
eip: 1492
title: Apeiron
author: German Abal Bazzano (@ariutokintumi)
discussions-to: https://twitter.com/EIP1492
type: Standards Track
category: ERC
status: Pre-Draft
created: 2022-10-16
updated: 2023-05-23
requires: 
---

## Simple Summary

A fully decentralized and secure tokenization protocol that ensures complete ownership of our tokens, referred to as 'Signs'. These Signs maintain a direct on-chain correlation with what they represents and can move through the grid formed by all the protocol users. Aditionally, each Sign can be authenticated through digital signatures embedded within its metadata.

## Abstract

The following standard allows for the implementation of a standard API for Signs within Consoles (Proxy Smart Contracts) and Cartridges (Execution Smart Contracts). This standard provides functionality to deploy a standard Console and a standard Cartridge (the first Cartridge version IS named 'Pong') which guarantees their full compliance to the EIP-1492 (Apeiron) protocol using EXTCODEHASH whitelists. 

The Console is responsable of create, store and delete Signs, modify ONLY their metadata and shield the integrity of the tokens mapping, while the Cartridge run the functions to operate with the Signs and transact with remote Consoles only by the compliance. The Console will mint and burn Signs and modify ONLY the metadata of the Signs, by the Cartridge requests, not being capable to modify other token information at all. The Signs validation/certification happens on the metadata layer and is, in most cases, an off-chain process, unless a user wants to store it fully on-chain, something not relevant at this point.

Let's see a diagram of the EIP-1492 Handshake:

                             +-----------+                                   +-----------+ 
                             | Cartridge |                                   | Cartridge |
                             +-----------+                                   +-----------+ 
        User ----- tx -----> | Console 1 | <------ EXTCODEHASH CHECKS -----> | Console 2 |
                             +-----------+                                   +-----------+
                             |   Signs   |                                   |   Signs   |
                             +-----------+                                   +-----------+ 

On the Handshake both Consoles checks the EXTCODEHASH of the remote Console and Cartridge, if both (Console and Cartridge) are whitelisted, for both of the Consoles, it proceeds normally with the requested User tx, which can go trought or be reverted depending on other circumstancial factors but not depending on the protocol. i.e. an unexpected token pull/push request.

Note that for the EIP-1492 Apeiron compliance both Consoles smart contracts MUST have identical code (but MUST NOT be the same contract address), but the Cartridge smart contracts address could be the same (not strictly neccessary but is the recommendation) since the code MUST be exactly the same for this proposal.

We have considered use cases where Signs are minted, owned, and transacted by Consoles trought the Cartridges compliance functionaly. Consoles are owned only by individuals and transacted by the owner and other Consoles, with the option to grant permissions to third-party 'operators'. Signs are a representation token that provides total ownership (not just rights) of any hashable or relationable thing, object and asset, using a direct relational algorithm/fingerprint of it, something that MUST be defined by each project information. The Signs have the property to represent anything on-chain, so it can be directly related to a digital content, abstraction, or physical object. We have considered a diverse universe of assets, and we know you will dream up many more. The goal is to achieve decentralization, ownership, relationship, and verification, which NFTs (ERC-721 and ERC-1155) cannot deliver, but many other opportunities are coming with this Console/Cartridge architecture.

To accomplish this objective, we need to ensure the origin and credibility of the tokens. Thus, the Consoles provide the users and Cartridges the ability to mint Signs but never alter them, except for the metadata which can change as many times as is needed. This guarantees that the tokens cannot be duplicated or re-minted as the same, not even by the Console owner in the same Proxy Smart Contract Storage.

Let's explore the structure of the EIP-1492 token (Signs) mapping on the Console Storage. This mapping is only accessible through Console functions and cannot be directly altered by Cartridges or the smart contract owner

        +-----------------+--------------+----------------+
        | string tokenId  | uint256 key  | byte metadata  |
        +-----------------+--------------+----------------+

- The 'tokenId' is created alongside the token and remains unchangeable, thereby preserving the token's intended relationship. It can only be removed when the token is burned.
- The 'key' is an auto-incrementing value that never decreases, regardless of whether a lower value is deleted. This design prevents token impersonation. It can only be removed when the token is burned.
- The 'metadata' comprises binary code of compressed metadata using the 'brotli' algorithm. Since this computation is always performed off-chain, this will save data and storage tx costs. It can be empty if the user hosts it's own tokens metadata and configured the Cartridge to avoid writting it down in Storage. This can be done by the combination of optional configurations.

Here is a list of what Signs can tokenize:

- images, videos, digital content, contracts, relational data, POAPs, music, books, properties, canvas, strokes, logos, graffiti, sounds, fingerprints, diamonds, documents, sign language, smells, patents, plans, molecules, text, radio frequencies, secret messages and anything else that can be hashed, even time!

Through the use of metadata, the Signs can embed or be associated with the content that generated it or any other content. If it is the latter case, the token can be considered as a key that requires knowledge of what generated it to indentify and access the associated content, a secret message. This is later explained in the Metadata section. The content possibilities include, but are not limited to, all the current use cases of NFTs.

NFTs lack a direct on-chain relationship with the "thing" they represent, as per the standard. Additionally, the ownership system is weak, often amounting to a third-party centralized right to own. Also, in many cases, the smart contract owner retains full control over the NFTs, allowing him to change the ownership of the tokens.

Furthermore, there is no standard protocol for NFTs to prevent common smart contract vulnerabilities, such as undesired metadata replacement or loss of ownership rights, also there is a weak relationships between tokens and their intended representations. In contrast, Signs have an explicit relationship with their 'tokenId', representing only one thing and preventing the possibility of obtaining a different output from what generated it. As a result, the proof of the relationship is stored on-chain, ensuring greater security and reliability.

The ownership associated with NFTs is, at best, a right that produces ownership through the interpretation of smart contract rules and a function called "owner." However, this ownership is in fact just a right that can be revoked in some cases. If we want to achieve true ownership and decentralization, we need to own our tokens that represent something verifiable and reside in our own smart contrac. From there, we can build any dApp that requires this structure. This is exactly what happens with Signs, Consoles and Cartridges, where tokens are literally created, owned, and transferred between a grid of all the compliance Consoles and interacting with the desired Cartridges, which act as nodes in the grid and enable the possibility to move in all directions and also extend the functionallity.

I know that probably many developers are wondering now "how can I mint a 10,000 tokens collection with this shielded standard?", a task that is straightforward with NFTs. I won't propose that 'new standard'(?) here to avoid confusion, but the code for that Cartridge is not difficult to envision. I would love if the creator of it decides to name it 'Asteroids'. Given the differing EXTCODEHASH, each user would need to whitelist the 'Asteroids' Cartridge, naturally after the mandatory community audits! Then users can enjoy the new possibilities that this Cartridge would bring (at their own risk!).

Many security and critical considerations are taken and listed in the Specification, such as owner-changes and storage collisions.

## Motivation

A standard interface facilitates wallets, brokers, social, gaming, and marketplace dApps to interact seamlessly and with confidence with any Console on the Ethereum network grid. This is particularly provided for ERC-1492 smart contracts, otherwise known as Consoles, vaults, or nodes of the grid, that are capable of owning and managing Signs through compliance Cartridges. Further applications will be explored in the following sections.

This EIP-1492 Apeiron token standard builds upon the well-known ERC-721 token standard, drawing from four years of collective experience since its introduction. However, ERC-721 design has inherent centralization, security shortcomings and an insufficient framework for correlating tokens with their intended representations. This is primarily due to the lack of direct on-chain connection or relationship between each asset and its representation, thus requiring off-chain information for this purpose. In stark contrast, Signs are fully decentralized, secure, and provide complete ownership to the Console owner. They are also directly connected to their representation on-chain, thereby offering a more robust and reliable solution for asset ownership and verification.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

**Every ERC-1492 compliant contract must be verified by the `ERC1942compliance` function before any transaction** (subject to "caveats" below):

```solidity
pragma solidity ^0.8.0;

/// @title ERC-1492 Apeiron
/// @dev See https://github.com/eth-sign/eip-1492
/// Note: the ERC-1492 identifier EXTCODEHASH is 0x7f6c9d6d00000000000000000000000000000000000000000000000000000000 (dummy data).
interface ERC1492 {
    /// @dev This emits when an FCS will be sent to a SIC. This event
    ///  emits unit_256 _clone value when FCSs are created (`from` == 0) and 
    ///  destroyed (`to` == 0) by _tokenId collsisions. Exception: Any number of
    ///  FCSs can be created and assigned without emitting Transfer. At the 
    ///  time of any transfer, the _tokenId with _clone match is deleted and a 
    ///  _clone reclassification occurs.
    event Transfer(address indexed _to, uint256 indexed _tokenId, uint256 indexed _clone);
    
    /// @dev This emits when pre-aproval to a SIC address to pull an FCS is changed or
    ///  reaffirmed. The zero address indicates there is no approved SIC address.
    ///  When a Transfer event emits, this also indicates that the approved
    ///  SIC for that FCS is reset to none.
    event pullApproval(address indexed _approved, uint256 indexed _tokenId, uint256 indexed _clone);
    
    /// @dev This emits when an operator is enabled or disabled for managing the SIC.
    /// The operator can manage all the FCSs in this vault.
    event ApprovalForAll(address indexed _operator, bool _approved);

    /// @dev This emits when a SIC is locked or unlocked for receiving tokens.
    /// If is locked (true) no receiveTransfer action can be executed by others than the 
    /// whitelisted SICs.
    event SetLocking(bool _approved);
    
    /// @dev This emits when an whitelisted is enabled or disabled for managing the SIC.
    /// The whitelisted contract can push FCSs in this vault bypassing a possible Locked status.
    event WhiteListed(address indexed _whitelisted, bool _approved);    

    /// @notice Query if an address is an authorized operator for the SIC
    /// @param _whitelisted The address that will be able to bypass a Locked status on the SIC.
    /// @return True if `_whitelisted` is an approved SIC, false otherwise
    function isWhisteListed(address _whitelisted) external view returns (bool);
    
    /// @notice Query if an contract address is an authorized operator for the SIC
    /// @param _operator The address that acts on behalf of the SIC owner
    /// @return True if `_operator` is an approved operator, false otherwise
    function isApprovedForAll(address _operator) external view returns (bool);

    /// @notice Count all FCSs on existance in the SIC
    /// @return The number of FCSs on existance, possibly zero
    function balanceOf() external view returns (uint256);
    
    /// @notice Check the existence of an FCS and if yes, the number of clones
    /// @dev 0 means there is no FCS in the SIC, 1 means a true or just 1 FCS, a 
    /// different number means a quantity including the _clones.
    /// @param _tokenId is the FCS to check
    /// @param _clone is the optional _clone of the FCS to check
    function checkOf(uint256 _tokenId, uint256 _clone) external view returns (uint256);

    /// @notice Find the pointer of a vault
    /// @dev FCSs pointing to nothing are considered invalid, and queries
    /// about them do throw.
    /// @return The _pointer of the vault directory in IPFS
    function pointer() external view returns (_pointer);

    /// @notice Changes the data pointer of the vault from one to another, this changes the association
    /// @param _pointer The string data Pointer to IPFS to change to
    function changeDataPointer(string _pointer) external payable;

    /// @notice Mint an FCS 
    /// @dev Throws unless `msg.sender` is the current owner or an authorized
    /// operator for this SIC. This outputs the _clone value (`from` == 1)
    /// for this FCS.
    /// @param _tokenId The FCS token ID product of the "not alrogithm" algorithm hash
    function Mint(uint256 _tokenId) external payable (_clone);

    /// @notice Transfers the ownership of an FCS from our SIC to another SIC
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator for this SIC or if `_to` is the zero address. 
    ///  Throws if `_tokenId` and `_clone` are not a valid FCS pair. When transfer is complete, 
    ///  this function calls `onERC1492Received` on `_to` and throws if the return value is not
    /// `bytes4(keccak256("onERC1492Received(address,uint256,uint256,string)"))`.
    /// @param _to The new SIC
    /// @param _tokenId The FCS token ID to transfer
    /// @param _clone The FCS _clone value of the _tokenId to transfer
    function safeTransferFrom(address _to, uint256 _tokenId, uint256 _clone) external payable;

    /// @notice This function let pre-aprove a FCS pullRequest transfer
    /// to some specific SIC
    /// @dev Throws unless `msg.sender` is the current owner or an authorized
    ///  operator for this SIC. 
    /// @param _to The SIC approved to pull the FCS
    /// @param _tokenId The FCS token ID to be approved for transfer
    /// @param _clone The FCS _clone value of the _tokenId to transfer
    function pullFunction (address _to, uint256 _tokenId, uint256 _clone) external payable;

    /// @notice Process a request to pull a pre-approved FCS to the requestion SIC
    /// @dev Throws unless `msg.sender` is the pre-approved SIC for the FCS token
    /// @param _to The SIC approved to pull the FCS
    /// @param _tokenId The FCS token ID to be approved for transfer
    /// @param _clone The FCS _clone value of the _tokenId to transfer   
    function pullRequest (address _to, uint256 _tokenId, uint256 _clone) external payable;

    /// @notice Receives a token from a SIC
    /// @dev Throws unless `msg.sender` is an SIC EIP-1492 compliance checked by
    /// ERC1942compliance function or Locking is 'true'. If address _from is 
    /// whitelisted the function will continue only if `msg.sender` is an SIC 
    /// EIP-1492 compliance.
    /// @param _to The SIC approved to pull the FCS
    /// @param _tokenId The FCS token ID to be approved for transfer 
    function receiveTransfer (address _from, uint256 _tokenId, pointer) external payable;
	
    /// @notice This configures an operator to managing the SIC.
    /// @dev Throws unless `msg.sender` is the current owner or an authorized
    ///  operator for this SIC. 
    ///  The operator can manage all the FCSs in this vault.
    /// @param _operator The _address approved to become operator
    /// @param _approved The value `true` or `false` to configure the state
    function ApprovalForAll(address _operator, bool _approved) external payable;
    
    /// @notice This adds a SIC address into the White List to bypass a locked state.
    /// @dev Throws unless `msg.sender` is the current owner or an authorized
    ///  operator for this SIC. 
    /// The whitelisted SIC can use the receiveTransfer if the Locked state is 'true'.
    /// @param _whitelisted The _address approved to become a whitelisted SIC.
    /// @param _approved The value `true` or `false` to configure the state
    function WhiteListed(address _whitelisted, bool _approved) external payable;

    /// @notice This changes the SIC state to be locked or unlocked what prevents to
    /// call the receiveTransfer function.
    /// @dev Throws unless `msg.sender` is the current owner or an authorized
    /// operator for this SIC. 
    /// Any SIC can use the receiveTransfer to send FCS (by the protocol) into this vault 
    /// when Locking is false.
    /// @param _approved The value `true` or `false` to configure the state
    function SetLocking(bool _approved) external payable;

    /// @notice Query if a remote contract is compliance with EIP-1492 using the EXTCODEHASH
    /// @stored The function getRemoteExtCodeHash uses less than 700 gas
    /// @return a string `true` if the remote contract EXTCODEHASH is the expected or 
    /// `false` if is not.
    function ERC1942compliance(address _to) external view returns (bool);
}
```
A wallet/broker/auction application MUST implement the **wallet interface** if it will accept safe transfers.

The **metadata extension** is OPTIONAL for ERC-1492 smart contracts (see "caveats", below). This allows your smart contract to be interrogated for its name and for details about the assets which your FCS is associated to.

```solidity
/// @title ERC-1492 First Come Signature, optional metadata extension
/// @dev See https://github.com/eth-sign/eip-1492
interface ERC1492Metadata /* is ERC1492 */ {
    /// @notice A descriptive name for a collection of FCSs in this contract
    function name() external view returns (string _name);

    /// @notice An abbreviated name for FCSs in this contract
    function symbol() external view returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid FCS. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC1492
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId, uint256 _clone) external view returns (string);
}
```

This is the "ERC1492 Metadata JSON Schema" referenced above.

```json
{
    "title": "Asset Metadata",
    "type": "object",
    "properties": {
        "validator_n": {
            "type": "string",
            "description": "A signature of the _tokenId itself and extended data (as current_owner, past_owner, timestamps, etc) by third party 'n' validator that is proposed for implementation of a validation as a trusted source of information for authenticity or certification. This can be implemented with consensus protocols, open protocols, private rings, centralized protocols, etc."
        }       
        "protected_code": {
            "type": "string",
            "description": "Optional, BASE64 string of the encrypted ''name', 'description' and 'value' and other metadata values. Optional and just used when the metadata is encrypted using a key directly related of what generated the token with an standard hash algoritm to be determined, different from the used to create the _tokenId hash/fingerprint. This MUST NOT be used in conjuntion with 'content_generator'"
        }        
        "content_generator": {
            "type": "string",
            "description": "Optional, this refers to the input thing that generated the tokenId through the direct relational algotithm/fingerprint. This MUST NOT be used in conjunction to 'protected_code',"
        }        
        "name": {
            "type": "string",
            "description": "Identifies the asset to which this FCS represents"
        },
        "description": {
            "type": "string",
            "description": "Describes the asset to which this FCS represents"
        },
        "image": {
            "type": "string",
            "description": "A URI pointing to a resource with mime type image/* representing the asset to which this FCS represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."
        }
    }
}
```

### Caveats

This pre-draft is originated from ERC-721 proposal. As such this Caveats, the next References and other components might appear to be a bit out of context. We acknowledge this and are actively learning and working on it.

The 0.4.20 Solidity interface grammar is not expressive enough to document the ERC-1492 standard. A contract which complies with ERC-1492 MUST also abide by the following:

- Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: `payable`, implicit nonpayable, `view`, and `pure`. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a `payable` function in this interface may be implemented as nonpayable (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.20 is that you can edit this interface to add stricter mutability before inheriting from your contract.
- Solidity issue #3419: A contract that implements `ERC1492Metadata` SHALL also implement `ERC1492`.
- Solidity issue #2330: If a function is shown in this specification as `external` then a contract will be compliant if it uses `public` visibility. As a workaround for version 0.4.20, you can edit this interface to switch to `public` before inheriting from your contract.
- Solidity issues #3494, #3544: Use of `this.*.selector` is marked as a warning by Solidity, a future version of Solidity will not mark this as an error.

*If a newer version of Solidity allows the caveats to be expressed in code, then this EIP MAY be updated and the caveats removed, such will be equivalent to the original specification.*

## Rationale

There are many proposed uses of Ethereum smart contracts that rely on tracking distinguishable assets, but existing asset standards such as NFTs fail to deliver on users expectations for: Decentralization, Ownership, Relationship, and Verification.

**"Consoles" and "Cartridges" Word Choice**

The Proxy smart contract is responsible for creating, securing, and storing tokens, based on requests from the Execution smart contract, which operates under a specific, changeable configuration. The Proxy consistently ensures protocol compliance from all counterparties, working solely under the agreed-upon standard. This is achieved by maintaining checks with remote Proxies and Execution smart contracts in every transaction. It is anticipated that the community of developers will create a variety of Execution smart contracts, offering diverse use cases and promoting widespread adoption of their protocol implementation. That's why we've dubbed the Proxy smart contracts 'Consoles' and the Execution smart contracts 'Cartridges'. Future versions of both can emerge, always striving to maximize potential while safeguarding the redundancy and security of the token Storage.

**"Signs" Word Choice**

'Signs' is a reference to 'signature', inspired by one of the primary features of EIP-1492 tokens: their relationship with the entity they originate from. This term found wide acceptance among virtually everyone who was NOT surveyed, and is applicable to an extensive range of distinguishable digital assets. Previously, we used a different name, FCS (First Come Signature), due to its relevance in the context of social networks, something that originated and inspired us to build this standard. However, we ultimately decided that 'sign' is more descriptive for most applications of this standard. Therefore, we will refer to these as 'sign' or 'signs' moving forward. (and back!).

*Alternatives considered: FCS, syn, Apeiron (now is the Protocol name), real NFT, NFT*

**Sign Identifiers**

Each Sign is identified by a unique pair of 'uint256' values, namely the 'tokenId' and the 'key', within an ERC-1492 smart contract. It is NOT possible for the identifiers to change over the lifetime of the contract. Therefore, the combination of the '(contract address, uint256 tokenId, uint256 key, chain)' will be a globally unique and fully-qualified identifier for a specific asset on an EVM compatible chain. The 'tokenId' and 'key' should be treated as a "black box", and it is important to note that Signs can become invalid and be destroyed in the standard EIP-1492 Cartridge, called "Pong".

The choice of `uint256` allows a wide variety of applications because UUIDs and sha3 hashes are directly convertible to `uint256`.

**Privacy**

Wallets/brokers/auctioneers identified in the motivation section have a strong need to identify which Signs some Console owns.

It may be interesting to consider this new asset is not enumerable, such as a private registry of property ownership, or a partially-private registry and many other new use cases are available. However, privacy should be extensively reviewed.

**Metadata Choices** (metadata extension)

We have required `name` and `symbol` functions in the metadata extension. Every token EIP and draft we reviewed (ERC-20, ERC-223, ERC-677, ERC-777, ERC-827, ERC-721) included these functions.

We remind implementation authors that the empty string is a valid response to `name` and `symbol` if you protest to the usage of this mechanism. How a client may determine which ERC-1492 smart contracts are well-known (canonical) is outside the scope of this standard.

A mechanism is provided to associate Signs with URIs. We expect that many implementations will take advantage of this to provide metadata for each Sign. The image size recommendation is taken from an old vintage token called NFT, they probably knew about image usability or copied from someone. The URI MAY be mutable (i.e. it changes from time to time). We considered a Sign representing ownership of a mansion, in this case metadata about the mansion (image, occupants, etc.) can naturally change.

The metadata is stored and returned as a byte value, compressed using 'brotli' algorithm, in the order to save gas on every transaction because the less use of transactional data and/or storage. Other tokens, like NFTs, stores the metadata using a string value: 'text plain' or 'base64' (even worst). Since this information is mainly used off-chain from the `web3` by dApps, NOT from other contracts, we find this change accurrate because we have not considered a use case where an on-chain application would query such information and need to use a decompress and decodification on a node, something that whould be very expensive.

The metadata URI will either be generated by the Console when the owner uploads their token metadata to their own storage, or it will be directly transferred from the Storage for each individual token in cases where the former is not applicable.

*Alternatives considered: put all metadata for each asset on the blockchain (too expensive), use URL templates to query metadata parts (URL templates do not work with all URL schemes, especially P2P URLs), multiaddr network address (not mature enough)*

**Community Consensus**

Let's start the discussion!!!

We were at ETHDenver 2023, ETHBogota 2022 and DEVCON VI where we discussed our project to create distinguishable asset standards. We invite you to review our project notes which will be published soon, please visit our Twitter account https://twitter.com/EIP1492 for more information and updates in the meanwhile this is not published for Draft review.

We have made an effort to be inclusive in this process and welcome anyone with questions or contributions to join our discussion. However, please note that this standard is specifically designed to support NOT ONLY the identified use cases listed herein.

## Backwards Compatibility

We have adopted `balanceOf`, `name` and `symbol` semantics from the ERC-20 specification. 

## References

**Standards**

1. [ERC-20](./eip-20.md) Token Standard.
1. [ERC-165](./eip-165.md) Standard Interface Detection.
1. [ERC-173](./eip-173.md) Owned Standard.
1. [ERC-223](https://github.com/ethereum/EIPs/issues/223) Token Standard.
1. [ERC-677](https://github.com/ethereum/EIPs/issues/677) `transferAndCall` Token Standard.
1. [ERC-827](https://github.com/ethereum/EIPs/issues/827) Token Standard.
2. [ERC-721](https://github.com/ethereum/EIPs/issues/721) Token Standard.
3. [EIP-1967](https://github.com/ethereum/EIPs/issues/1967) Proxy Storage Slots.
4. Ethereum Name Service (ENS). https://ens.domains
5. JSON Schema. https://json-schema.org/
6. Multiaddr. https://github.com/multiformats/multiaddr
7. RFC 2119 Key words for use in RFCs to Indicate Requirement Levels. https://www.ietf.org/rfc/rfc2119.txt

## Copyright

OPEN SOURCE MIT LICENCED PROJECT cc0 & everything that states that this is totally free
